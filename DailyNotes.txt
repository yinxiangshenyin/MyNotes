this note is for the design of the python pjsip


------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
python\pjsip\install
在python环境中安装pjsua的步骤 关键词：python pjsua
1、下载最新的pjsip源码 http://www.pjsip.org/
2、下载支持python3的pjsua源码并复制到pjsip相对应的位置https://github.com/mgwilliams/python3-pjsip
3、用vs2015/vs2008打开pjsip,选择debuge/release 以及win32的编译方式
4、将python_pjsua选择为启动项，并添加dirtx和python的include、lib到python_pjsua的工程环境
		Add Python include directory (e.g. C:\Python24\include) to Visual Studio include directories.
		Add Python library directory (e.g. C:\Python24\libs) to Visual Studio library directories.
		C:\Python24\  #包含python.dll
		DirectX\include
		DirectX\Lib\X86
5、编译python_pjsua
6、Go to pjsip-apps\src\python directory
   Run python setup-vc.py install (note that the installation script is setup-vc.py and not setup.py).
   
7、在python的环境下import pjsua

------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
data:2017-9-18
python\pjsip\Qthread:

	Qt 之 QTthread（深入理解）
	PyQt 线程类 QThread使用详解
	
	1、import pyQt5.QtCore
	2、新建一个class 继承 QtCore.QThread
	    from PyQt4 import QtCore
		class mythread(QThread):
			  send=pyqtSignal(str,int)
			  def __int__(self):
				super(mythread, self).__init__()
			  def setValue(self,state,number):
				self.state=state
				elf.number=number
			  def run(self):
				self.send.emit(self.state,self.number)
	        -------------
		#globle variable
		workThread = mythread()
		workThread.send.connect(get_function) 
		-------------
		#in other thread the workThread passed to the thread as myworkThread. 
		myworkThread.setValue("ceshi", 123)  
		myworkThread.start()
		-------------

    3、注意点
	    thread需要是全局变量，因为如果在定义为局部变量，会在函数结束时自动销毁，从而使得线程的run函数未执行就结束
------------------------------------------------------------------------------------------------------------------------
date: 2017-9-19
python\pjsip\plantronics:
	1、根据官网下载设备管理客户端
	2、根据官网的python脚本获取设备信息，需要循环不断的调用get_events()方法获取事件信息
		connecting to hub rest api in python
	3、phtronices sdk  
	
	待完整。。。。。
	
pdf转word：
    1、百度下载“wmPDFzhcWord”----http://www.jb51.net/softs/397601.html
	2、解压并将COMDLG32.OCX复制到文件夹C:\Windows\SysWOW64 --这是64位的电脑，32位的系统放在 c:\Windows\system32
	3、以管理员的方式运行CMD 输入regsvr32 C:\Windows\SysWOW64\COMDLG32.OCX
	4、运行完美PDF转换成Word转换器.exe
	注意：
		如果出现“DllRegisterServer的调用失败”则是没有以管理员运行CMD
		
mathtype：
	1、下载mathtype 并安装到自定义的路径上
	2、在安装路径中打开mathtype.exe 既可以进行公式编辑
	3、编辑好的公式可以复制到word上即可
	
	注意
	    通过 样式-数字 可以将打出的字符变成倾斜
		在 样式-文本 的环境下可以给公式打上空格
		想要粗体并倾斜可以编辑 样式-定义-向量矩阵：勾上粗体和斜体，在使用过程中将输入的字符定义为向量矩阵即可实现字符效果
		
Get a picture
	我与宫崎骏 https://www.duitang.com/blog/?id=509882939
	设置了头像 并上传到百度云 百度云-个人资料-照片-20160108102243_hFRGU.jpeg

kedacom（科达）\内网测试
    将数据抓包文件上传到百度云 公司项目-应急指挥系统-苏州-专网内网建设-镜像抓包
	以及省公司开设的端口信息存在 公司项目-应急指挥系统-苏州-专网内网建设-镜像抓包-2648774888720219.jpg
	
------------------------------------------------------------------------------------------------------------------------
date：2017-9-20
python\tensorflow\ASR:
    tensorflow 不可以安装在32位的系统上
	如何高效的从文件中获取数据：
		编写了一个read_csv.py 在other的路径子下
		参考：ttensorflow载入数据的三种方式、ensorflow 读取数据之SCV格式、如何正确从csv的数据读入tensoflow、python读取并写入csv文件、python读取csv到矩阵中
		全部加载：
			利用pickle.load() 内存持续增加1.7G 8911条数据 运行时python为5G
			从pickle 装载的数据（内存）一个16batch 需要7s（在suda-pc上运行的结果）
		如何一边读一边写入：
			CSV：---------------------------------------------------------------------------------------------------------------------
				csv文件格式是 number,number,number..,每一个逗号隔开的就是一列
				同时保证每一行的列数相同，即是一个向量而不是列表
				[1,2,3]
				[4,5,6]
				在csv文件中就是2行3列
				normal：------------------------------------------------------------------
				    writer：
						data=[[...],[...],[...]]
						csvfile=open(mydata,'w',newline="")
						writer=csv.writer(csvfile)
						m=len(data)
						print(m)
						for i in range(m):
							writer.writerow(data[i])
						csvfile.close()
					
					read：
						with open(mydata,'r') as csvfile:
							reader=csv.reader(csvfile)
							for item in reader:
								print(item)
				
				numpy:--------------------------------------------------------------------
					writer：
						my_martix=np.loadtxt(open('1.csv','rb'),delimiter=",",skiprows=0)	
					read：					
						np.savetxt('1.csv',my_martix,delimiter=",")
					-----------------------------------------------------------------------
				
			QueueRunner:-------------------------------------------------------------------------------------------------------------------
				tf.train函数添加QueueRunner到数据流图中，当训练时，需要调用tf.train.start_queue_runner函数，否则数据流图将一直挂起，
				tf.train.start_queue_runner函数将会启动输入管道的线程，并填充样本到队列中，以便于tf.train从队列中提取数据
				1、创建文件queue：
					file_name=[filename1,filename2..]
					file_queue=tf.train.string_input_producer(file_name,shuffle=False)
						shuffle:文件的出对入队不是随机的
						每次read数据是从文件队列中的第一个文件中读取一行内容，读取完该文件就会出对并到达队列底部
				2、设置读取的方式以csv为例
					reader=tf.TextLineReader()
					key,value=reader.read(file_queue   -----读取一行
					label1,label2,label3,label4,label5,label6=tf.decode_csv(value,record_defaults=[[1],[1],[1],[1],[1],[1]]) --读取一行的几列
						csv文件格式是 number,number,number..,每一个逗号隔开的就是一列，在读取的时候定义读取格式时是要根据列数[[1],[1],[1]..]
						同时保证每一行的列数相同，即是一个向量而不是列表
						[1]是读取后转成int
				3、设置batch方式读取数据
					batch_label1..batch_label6=tf.train.batch([label1,label2,label3,label4,label5,label6],batch_size=4,capacity=10,num_threads=1,allow_smaller_final_batch=4)		
						tf.train.batch是按顺序读取文件中的数据
						batch_label1是一列4行的数据
						当达到文件底部时，将会迭代到文件头部
							[[25 26 27 28 29 30]
							 [31 32 33 34 35 36]
							 [ 1  2  3  4  5  6]
							 [ 7  8  9 10 11 12]]
				4、start
				    init_all_varible()
					coord=tf.train.Coordinator()
					thread=tf.train.start_queue_runners(coord=coord)
				5、获取数据
				    for i in epoch
						feed_dict={x:batch_label1}
						
				其中第三步骤是根据实际的文件格式定义
				这其实就是用线程一行一行读取文件中的数据，并通过queue的方式反馈到主线程，同时设置queue的长度
						
					
					
					
					
				
				
			
	
	关于shape
		tf.cast(x,dtype,name=None)可以将矩阵转换成dtype格式
		tf.shape(x)可以获tensor的shape
		(input.get_shape()).as_list()可以将tensor的shape转换成list格式
		e=np.array（） e.shape（）获取shape
		type（）是python的函数
	
Anaconda	
	几个常用命令：
		新建环境：conda create --name py35 python=3.5 anaconda
		激活环境：activate py35
		退出环境：deactivate
		在环境中进入python： python3-pjsip
		在python中退出到环境： exit（）
		列出环境：conda info --envs
		删除环境：conda remove --name py35 --all
		
--------------------------------------------------------------------------------------------------------------------------------------------
2017-9-21
tensorflow\ASR：
	字典反转：word_class={v:k for k,v in word_class.items()}
	逐行读取数据：(csv格式：是一条数据一行)
		with open(file_name) as read:
			read.readline()
	读取文档的行数：
		count = -1
		for count, line in enumerate(open(save_labels, 'rU')):
			 pass
		count += 1
		print(count)
--------------------------------------------------------------------------------------------------------------------------------------------		
2017-9-22
python\pjsip\plantronics:
	Accessing USB devices via HID：https://developer.plantronics.com/article/accessing-usb-devices-hid
		via the usb to get the event of plantronics
	Calisto p240 用的是自定义的协议，需要联系官方网站
	
		
python\pjsip\pjsua
    参考pjusa文档
		
python\usb	
	一、通过usb.core.find()发现设备，通过write&read函数实现通讯
		具体过程大致如下：
		device = usb.core.find(idVendor=_vend, idProduct=_prod)

		# 内核驱动是否处于活动状态
		if device._kernel_driver_active(0): # interface is int
		try:
		# 分离内核驱动（不晓得这样翻译是否妥当）
		device.detach_kernel_driver(0)
		except usb.core.USBError as e:
		sys.exit("Could not detatch kernel driver: %s" % str(e))

		# ep地址解析：例如0x02--> 0000 0010 表示传输方向为OUT（第一位为0, 若为1则为IN） 0010为2 即为EP2,所以该地址意思为为: EP2且传输方向为OUT
		ep = device[0][(0,0)][1].bEndpointAddress
		# sendlist为我要发送的列表 例如[0x01, 0x02, 0x03, 0x04], 不能直接发送，要先转换成array形式，如下所示：
		my_data = array.array('B',sendlist)
		# PC端向USB Device发送信息 write
		device.write(ep, my_data)
		
python\usb\HID	
	plantronics 240 是一个独特的设备因为它能够按键拨号，使用自定义的协议进行通信，需要供应商提供相应的协议说明代码
--------------------------------------------------------------------------------------------------------------------------------------------	
2017-9-23
github：
	关于Github的使用：
		在git项目中严禁存放大量的数据，数据应该保留在项目之外
	除了学校电脑上的工程，其他电脑修改的项目一律用分支方式，尽量不要建立太多的分支
	在工程中建立一个test文档并建立分支用于临时代码的检测
		
tensorflow\ASR：
	将训练数据以条目的方式存储到txt文档中，并通过readline的方式一条一条读取数据，可以提高读取速度，并占用很小的内存
	csv：
		import csv
		with open('A.csv','rb') as csvfile:
			reader = csv.reader(csvfile)
			for i,rows in enumerate(reader):
			if i == 2:
				print（rows）


自然语言处理（NLP）
	为什么深度学习能成功地应用到语音：
		一个机器能否拥有智慧最基础的就是看他能否接收到外面的视频音频数据，并作出反应，当机器能听懂人类的语言的时候，是非常令人兴奋的；
		在机器学习中最重要的是大量的数据，当语音的数据量达到3000小时的时候能够训练出较好的效果，第二个重要的地方就是保留数据的原始性，即最大的保留原始输入信号的特征，
		因为神经网路是特征提取的网络，随着层数的增加，成分越具体，将原始信号作为输入，最终从部分到整体抽象为我们感知的物体
	
	自然语言处理：
		自然语言处理中的词向量（word Embedding）方法对传统语言模型具有很大的提升
	word2Vec：（creatcodebuild）youtube
	
		什么是word2vec
			注重语义的分析，
			参考： chrisMcCormick Word2vec tutorial
			根据词汇与词汇之间出现的概率
			设置滑窗的大小，计算在滑窗中的的词汇出现后周围几个词汇出现的概率，一个词的语义与周围的词有恨到的关系
				简答的网络搭建：
					首先先给词进行编码：00001-10000
					建立一个两层的全连接神经网络，输入就是词汇码，输入也是词汇码，中间隐藏层300个
					建立滑窗，大小为5，滑窗中间的词就是输入，而其他词汇就是label，相当于一个输入有四个label
					训练好后，输入层与隐藏层之间的权重即为词向量，因为词汇编码是0/1 只有1的位置所对应的权重是激活的，所以1位置对应的权重就是该词的权重
					这就是为什么只有一个隐藏层的意义，其中隐藏层的神经元个数就是特征个数
					
		word2Vec前篇（上）语言模型
		
			逻辑模型：根据语法将一条语句分为主谓宾的语言结构 SVO，根据这个模型检索语句并提取信息
					  但是随着规则的增加，检索的任务将成指数增长
					  
					  
		    概率模型：计算上下文的词出现的概率，通过统计的方式得出，即通过学习的方式计算
			
		Word2vec前篇（下）非监督学习
			非监督学习：降维，feature_learning,k_mean
			非监督学习可以理解为：寻找一个set（集合）将相似的数据放在一个set中 
			
			raw->Word2vec->feature（vectore）
		Word2vec正篇（上） count based

		
	Some songs never get old..﻿
python
	 l=[]和l=None是给l赋一个新的值，不影响原来数组的内容
	 del l[:]，才是测地清除内存
	 

--------------------------------------------------------------------------------------------------------------------------------------------		
207-9-25
python\pjsip\plantronics:
	interacting with the plantronics devices without the sdk:connecting the plantronics via the HID
	plantrinics SDK : rest servce: connecting the plantroincs via the hub
		
		


	
	
		

	
	
